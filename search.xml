<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="posts/0.html"/>
      <url>posts/0.html</url>
      
        <content type="html"><![CDATA[{"title":"K近邻算法详解以及实现代码","id":"posts/bea7bbc1.html","date_published":"03/25/2021","summary":"","url":"https://www.bulingling.top/posts/bea7bbc1.html","tags":["KNN"],"categories":["机器学习"]}]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="posts/0.html"/>
      <url>posts/0.html</url>
      
        <content type="html"><![CDATA[importScripts('https://cdn.webpushr.com/sw-server.min.js');]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>K近邻算法详解以及实现代码</title>
      <link href="posts/bea7bbc1.html"/>
      <url>posts/bea7bbc1.html</url>
      
        <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>​        K-近邻算法(<code>K-Nearest Neighbour algorthm</code>),又称<code>KNN</code>算法，数据挖掘技术中原理最简单的算法。<code>KNN</code>的工作原理：给定一个已知的标签类别的训练数据集，输入没有标签的新数据后，在训练数据集中找到与新数据最邻近的k个实例，如果这k个实例的多数属于某个类别，那么新数据就属于这个类别。可以简单的理解为：由那些离x最近的k个点来投票决定x归为哪一类。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/KNN1.png" alt="KNN算法的图像解释"></p><ol><li><p>上图中有红色三角和蓝色方块两种类别，我们现在需要判断绿色的圆点属于哪种类别</p><p>当k=3时，绿色圆点属于红色三角这种类别。</p><p>当k=5时，绿色圆点属于蓝色方块这种类别。</p></li></ol><h2><span id="范数">范数</span></h2><p>​    在这里我不得不首先解释一下什么叫做范数，因为在距离度量的介绍中我们将会接触到这个概念。</p><p>​    我们知道距离的定义是一个宽泛的概念，只要满足<code>非负</code>、<code>自反</code>、<code>三角不等式</code>就可以称之为<code>距离</code>。范数是一种强化了的距离概念，它在定义上比距离多了一条<code>数乘</code>的运算法则。有时候为了便于理解，我们可以把范数当作距离来理解。</p><p>​    在数学上，范数包括向量范数和矩阵范数，向量范数表征向量空间中向量的大小，矩阵范数表征矩阵引起变化的大小。一种非严密的解释就是，对应向量范数，向量空间中的向量都是有大小的，这个大小如何度量，就是用范数来度量的，不同的范数都可以来度量这个大小，就好比米和尺都可以来度量远近一样；对于矩阵范数，学过线性代数，我们知道，通过运算，可以将向量X变化为B，矩阵范数就是来度量这个变化大小的。</p><p>​    向量的范数定义：<code>向量的范数是一个函数||x||,满足非负性||x|| &gt;= 0，齐次性||cx|| = |c| ||x|| ，三角不等式||x+y|| &lt;= ||x|| + ||y||。</code></p><h2><span id="距离度量">距离度量</span></h2><p>​    在这里我们首先要知道三个距离度量公式，分别是以下三个：</p><h3><span id="闵可夫斯基距离距离lp范数">闵可夫斯基距离距离(Lp范数)</span></h3><p>​    <code>Lp</code>距离定义：</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/Lp.png" alt="Lp距离"></p><p>​    其中<br>$$<br>x_i \in \mathbf{R}^n,x_j \in \mathbf{R}^n<br>$$</p><h3><span id="切比雪夫距离l范数">切比雪夫距离(L∞范数)</span></h3><p>​    L∞定义为：</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/L%E2%88%9E.png" alt="L∞距离"></p><p>​    其中p是一个变参数。</p><h3><span id="曼哈顿距离l1范数">曼哈顿距离(L1范数)</span></h3><p>​    首先简单介绍一下曼哈顿距离！</p><p>​    曼哈顿距离（Manhattan Distance）又叫出租车几何是由十九世纪的赫尔曼·闵可夫斯基所创词汇，是种使用在几何度量空间的几何学用语，用以标明两个点在标准坐标系上的绝对轴距总和。</p><p>​    当<code>Lp距离</code>的p=1时，就是我们的曼哈顿距离(对应<code>L1</code>范数)</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/8326cffc1e178a8208d61b83f603738da977e82f" alt="曼哈顿距离"></p><p>​    图中红线代表曼哈顿距离，绿色代表欧氏距离，也就是直线距离，而蓝色和黄色代表等价的曼哈顿距离。曼哈顿距离——两点在南北方向上的距离加上在东西方向上的距离，即<code>d(i,j)=|xi-xj|+|yi-yj|</code>。对于一个具有正南正北、正东正西方向规则布局的城镇街道，从一点到达另一点的距离正是在南北方向上旅行的距离加上在东西方向上旅行的距离，因此，曼哈顿距离又称为出租车距离。</p><p>​    曼哈顿距离不是距离不变量，当坐标轴变动时，点间的距离就会不同。曼哈顿距离示意图在早期的计算机图形学中，屏幕是由像素构成，是整数，点的坐标也一般是整数，原因是浮点运算很昂贵，很慢而且有误差，我们不妨假定左下角的点为A点，右上角的点为B点，左上角的点为C点，如果直接使用AB的欧氏距离（欧几里德距离：在二维和三维空间中的欧氏距离的就是两点之间的距离），则必须要进行浮点运算，如果使用AC和CB，则只要计算加减法即可，这就大大提高了运算速度，而且不管累计运算多少次，都不会有误差。</p><p>​    曼哈顿距离就是对应<code>L1-范数</code>，也就是在欧几里得空间的固定直角坐标系上两点所形成的线段对轴产生的投影的距离总和。例如在平面上，坐标<code>（x1, y1）</code>的点<code>P1</code>与坐标<code>（x2, y2）</code>的点<code>P2</code>的曼哈顿距离为：<br>$$<br>∣ x 1 − x 2 ∣ + ∣ y 1 − y 2 ∣<br>$$<br>​    注意：</p><p>​    曼哈顿距离依赖坐标系统的转度，而非系统在坐标轴上的平移或映射。下边我来解释一下曼哈顿距离依赖坐标系统的转度，就是曼哈顿距离随着坐标轴的变化值也会随之发生改变。就是上边所说的当坐标轴变动时，点间的距离就会不同。</p><p>​    <code>L1</code>范数表示为：</p><p>​        <img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/L1.png" alt="`L1`范数"></p><h3><span id="欧氏距离l2距离">欧氏距离(<code>L2距离</code>)</span></h3><p>​    欧几里得度量（euclidean metric）（也称欧氏距离）是一个通常采用的距离定义，指在m维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。在二维和三维空间中的欧氏距离就是两点之间的实际距离。    </p><p>​    欧氏距离是最常见的两点之间或多点之间的距离表示法，又称之为欧几里得度量，它定义于欧几里得空间中。n维空间中两个点<code>x1(x11,x12,…,x1n)</code>与 <code>x2(x21,x22,…,x2n)</code>间的欧氏距离</p><p>​    二维空间的公式：</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/o2.png" alt="二维空间的公式"></p><p>​    三维空间的公式：</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/o3.png" alt="三维空间的公式"></p><p>​    接下来我们把它推广到n维空间：</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/on.png" alt="n维空间的公式"></p><p>​    <code>L2</code>的范数:</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/l2.png" alt="L2的范数"></p><h2><span id="实例讲解">实例讲解</span></h2><p>​    举一个非常简单的例子，可以用k-近邻算法分类一个电源是爱情片还是动作片(打斗镜头和接吻镜头数量)。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/movie.png" alt="电影的打斗镜头数接吻镜头数"></p><p>​    上表就是我们已有的数据集合，也就是训练样本集，这个数据集有两个特征-打斗镜头和接吻镜头数。除此之外，我们也知道每部电影的所属类型，即分类标签。粗略看来。接吻镜头数多的就是爱情片，打斗镜头数多的就是动作片。我们大家也看过很多电影吧，这个分类还算比较合理的。但是如果我们吧特征扩展到n个，仅仅凭借我们的肉眼恐怕很难一眼看出电影的类型吧，而K-近邻算法可以根据我们给定的电影的特征数判断这部电影是属于什么类型的电影，这就是算法的艺术美魅力所在。</p><p>​    我们通过上文已经知道k-近邻算法的工作原理，根据特征比较，然后提取样本集中的特征最相似的数据(最近邻)的分类标签。那么如何进行比较呢，比如上图给出的新电影，我们应该如何判断电影所属的类型呢，我们接着看下图。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/pic.png" alt="电影分类"></p><p>我们可以根据散点图大致推断。这个未知电影很有可能是爱情片，因为看起来距离已知的三个爱情片更近一点。k近邻算法是如何判断呢，他是通过距离度量。这个电影分类的例子有两个特征，也就是在二维平面中计算两点之间的距离，就可使用我们高中所学过的距离计算公式：</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/distance_2.png" alt="AB两点之间的直线距离公式"></p><p>如果是多个特征扩展到N维空间，就是我们上文所提到的欧氏距离(欧几里得度量)，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/on.png" alt="n维空间的公式"></p><p>通过计算可以得到训练集中所有电影与未知电影的距离(在这里我就不为大家一步一步计算了，大家可以私下计算)，结果如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/ann_1.png" alt="与未知电影的距离"></p><p>通过上表的计算结果，我们可以知道绿点标记的电影到爱情片《后来的我们》距离最近，为29.1，。如果仅仅根据这一个结果，判断绿点电影的类别为爱情片，这个算法最近邻算法，而非叫做K-近邻算法。K-近邻算法步骤如下:</p><ol><li>计算已知类别数据集中的点与当前点之间的距离。</li><li>按照距离递增次序排序。</li><li>选取与当前点距离最小的k个点。</li><li>确定前k个点所在类别的出现的频率。</li><li>返回前k个点出现频率最高的类别作为当前点的预测类别。</li></ol><p>比如，现在k=4，那么在这个电影的例子里，把距离按照升序排列，距离绿点电影最近的前四个电影分别是《后来的我们》,《前任3》，《无问西东》，《红海行动》，这四部电影的类别统计为爱情片:动作片=<code>3:1</code>，出现频率最高的类别为爱情片，所以k=4，时，绿点电影的类别为爱情片，这个判别过程就是k-近邻算法。</p><h2><span id="k-近邻算法的python实现">K-近邻算法的python实现</span></h2><p>在了解k-近邻算法的原理以及实施步骤之后，我们用python将这些过程实现。</p><h3><span id="算法实现">算法实现</span></h3><h4><span id="构建已经分好类的原始数据集">构建已经分好类的原始数据集</span></h4><p>​    为了方便验证，这里使用python的字典<code>dict</code>构建数据集，然后再将其转换成<code>DataFrame</code>数据框格式。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pdrowdata <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"电影名称"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'无问西东'</span><span class="token punctuation">,</span><span class="token string">'后来的我们'</span><span class="token punctuation">,</span><span class="token string">'前任3'</span><span class="token punctuation">,</span><span class="token string">'红海行动'</span><span class="token punctuation">,</span><span class="token string">'唐人街探案'</span><span class="token punctuation">,</span><span class="token string">'战狼2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>           <span class="token string">"打斗镜头"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">108</span><span class="token punctuation">,</span><span class="token number">112</span><span class="token punctuation">,</span><span class="token number">115</span><span class="token punctuation">]</span><span class="token punctuation">,</span>           <span class="token string">"接吻镜头"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token number">89</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span>           <span class="token string">"电影类型"</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'爱情片'</span><span class="token punctuation">,</span><span class="token string">'爱情片'</span><span class="token punctuation">,</span><span class="token string">'爱情片'</span><span class="token punctuation">,</span><span class="token string">'动作片'</span><span class="token punctuation">,</span><span class="token string">'动作片'</span><span class="token punctuation">,</span><span class="token string">'动作片'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>           <span class="token punctuation">}</span>movie_data <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>rowdata<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>movie_data<span class="token punctuation">)</span><span class="token comment"># 结果</span>    电影名称  打斗镜头  接吻镜头 电影类型<span class="token number">0</span>   无问西东     <span class="token number">1</span>   <span class="token number">101</span>  爱情片<span class="token number">1</span>  后来的我们     <span class="token number">5</span>    <span class="token number">89</span>  爱情片<span class="token number">2</span>    前任<span class="token number">3</span>    <span class="token number">12</span>    <span class="token number">97</span>  爱情片<span class="token number">3</span>   红海行动   <span class="token number">108</span>     <span class="token number">5</span>  动作片<span class="token number">4</span>  唐人街探案   <span class="token number">112</span>     <span class="token number">9</span>  动作片<span class="token number">5</span>    战狼<span class="token number">2</span>   <span class="token number">115</span>     <span class="token number">8</span>  动作片<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="计算已知类别数据集中的点与当前点之间的距离欧氏距离">计算已知类别数据集中的点与当前点之间的距离(欧氏距离)</span></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">new_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">67</span><span class="token punctuation">]</span><span class="token comment"># 广播 按列求和</span>dist <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>movie_data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">-</span>new_data<span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>dist<span class="token punctuation">)</span><span class="token comment"># 结果</span><span class="token punctuation">[</span><span class="token number">41.048751503547585</span><span class="token punctuation">,</span> <span class="token number">29.068883707497267</span><span class="token punctuation">,</span> <span class="token number">32.31098884280702</span><span class="token punctuation">,</span> <span class="token number">104.4030650891055</span><span class="token punctuation">,</span> <span class="token number">105.39449701004318</span><span class="token punctuation">,</span> <span class="token number">108.45275469069469</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="将距离升序排列然后选取距离最小的k个点">将距离升序排列，然后选取距离最小的k个点</span></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">dist_1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>    <span class="token punctuation">{</span><span class="token string">'dist'</span><span class="token punctuation">:</span>dist<span class="token punctuation">,</span>     <span class="token string">'labels'</span><span class="token punctuation">:</span><span class="token punctuation">(</span>movie_data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>dr <span class="token operator">=</span> dist_1<span class="token punctuation">.</span>sort_values<span class="token punctuation">(</span>by<span class="token operator">=</span><span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>dr<span class="token punctuation">)</span><span class="token comment"># 结果</span>         dist labels<span class="token number">1</span>   <span class="token number">29.068884</span>    爱情片<span class="token number">2</span>   <span class="token number">32.310989</span>    爱情片<span class="token number">0</span>   <span class="token number">41.048752</span>    爱情片<span class="token number">3</span>  <span class="token number">104.403065</span>    动作片<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="确定前k个点所在类别出现的频率">确定前k个点所在类别出现的频率</span></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">re <span class="token operator">=</span> dr<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token string">'labels'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span><span class="token comment"># 结果</span>爱情片    <span class="token number">3</span>动作片    <span class="token number">1</span>Name<span class="token punctuation">:</span> labels<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="选择频率最高的类别作为当前点的预测类别">选择频率最高的类别作为当前点的预测类别</span></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>re<span class="token punctuation">.</span>index<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 结果</span>爱情片<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="函数封装">函数封装</span></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">classify</span><span class="token punctuation">(</span>inx<span class="token punctuation">,</span>dataSet<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    dist <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dataSet<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span> new_data<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">0.5</span><span class="token punctuation">)</span>    dist_1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>        <span class="token punctuation">{</span><span class="token string">'dist'</span><span class="token punctuation">:</span> dist<span class="token punctuation">,</span>         <span class="token string">'labels'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>movie_data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token punctuation">)</span>    dr <span class="token operator">=</span> dist_1<span class="token punctuation">.</span>sort_values<span class="token punctuation">(</span>by<span class="token operator">=</span><span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span>    re <span class="token operator">=</span> dr<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token string">'labels'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span>    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>re<span class="token punctuation">.</span>index<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是我们使用K-近邻算法构建的一个分类器，根据我们的经验可以看出，分类器给出的答案还是比较符合我们的预期的。</p><p>学习到这里，有人可能会问:”分类器何种情况下会出错?“或者”分类器给出的答案是否永远都正确?“答案一定是否定的，分类器并不会得到百分百正确的结果，我们可以使用很多种方法来验证分类器的准确率。此外，分类器的性能也会受到很多因素的影响，比如k的取值就在很大程度上影响了分类器的预测结果，还有分类器的设置、原始数据集等等。为了测试分类器的效果，我们可以把原始数据集分为两部分，一部分用来训练算法（称为训练集)，一部分用来测试算法的准确率（称为测试集)。同时，我们不难发现，k-近邻算法没有进行数据的训练，直接使用未知的数据与已知的数据进行比较，得到结果。因此，可以说，k-近邻算法不具有显式的学习过程。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tableau破解</title>
      <link href="posts/b334f9be.html"/>
      <url>posts/b334f9be.html</url>
      
        <content type="html"><![CDATA[<h2><span id="tableau简介">Tableau简介</span></h2><p><code>Tableau Software</code>致力于帮助人们查看并理解数据。Tableau 帮助任何人快速分析、可视化并分析享信息。超过 42,000 家客户通过使用 Tableau 在办公室或随时随地快速获得结果。数以万计的用户使用 <code>Tableau Public</code> 在博客与网站中分享数据。<code>Tableau Desktop Pro 2019.1</code>破解版是处理和分析信息、报告和绘图的最强大工具之一。<code>Tableau Desktop</code>基于<code>Web</code>分析和控制面板，为管理员提供了战略管理领域的强大工具。正好<code>Tableau</code>也是小编本学期的一门大数据可视化课程，欢迎大家可以评论区留言我，一起交流学习。</p><h2><span id="破解步骤">破解步骤</span></h2><blockquote><ol><li>双击<code>setup.exe</code>，安装软件</li><li>软件安装后，复制<code>tabui.dll</code>到软件安装目录下替换原文件</li><li>安装激活完成，Enjoy</li></ol></blockquote><h2><span id="具体流程">具体流程</span></h2><h3><span id="第一步">第一步</span></h3><p>双击<code>setup.exe</code>，安装软件。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/201805031059228.jpg" alt="初始界面"></p><p>我们选择自定义安装，修改<code>Tablau</code>的安装路径，否则的话它默认是安装在<code>C</code>盘(因为已经小编安装过了就从网上找了样图)。</p><p><code>默认路径C:\Program Files\Tableau\Tableau 2019.1\bin</code></p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/TableauDesktop2020.1-1.jpg" alt="自定义安装界面"></p><h3><span id="第二步">第二步</span></h3><p>软件安装后，复制<code>tabui.dll</code>到软件安装目录下替换原文件。</p><p><code>tabui.dll</code>文件位于与<code>setup.exe</code>同级目录的<code>Crack x64</code>文件夹下。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/22.png" alt="tabui.dll文件位置"></p><p>复制<code>tabui.dll</code>之后替换软件安装目录文件夹下的bin下的<code>tabui.dll</code>文件。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/22%20(2).png" alt="替换文件"></p><h3><span id="第三步">第三步</span></h3><p>安装激活完成 ，启动<code>Tableau</code>即可。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/21.png" alt="打开界面"></p><h2><span id="网盘下载文件">网盘下载文件</span></h2><p><code>网盘内选择下载想要的版本即可</code></p><p>网盘地址：<a href="https://pan.baidu.com/s/1aiX4GQvOcQ3E0VrskSlxwA">https://pan.baidu.com/s/1aiX4GQvOcQ3E0VrskSlxwA</a></p><p>密码私聊我QQ</p><p>后续小编会出一些大数据技术系列的和数据挖掘的博客。</p>]]></content>
      
      
      <categories>
          
          <category> 软件破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tableau破解教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pathlib库的Path类</title>
      <link href="posts/c3c36639.html"/>
      <url>posts/c3c36639.html</url>
      
        <content type="html"><![CDATA[<p>今天刚刚好学习到了pathlib库的Path类的使用，一起和大家分享一下。</p><h3><span id="调用库">调用库</span></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pathlib <span class="token keyword">import</span> Path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3><span id="创建path对象以及调用函数">创建Path对象，以及调用函数</span></h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'E:/python/a.py'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token comment"># 也可以这样子使用，想当于os.path.join()</span>p1 <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'E:/python'</span><span class="token punctuation">)</span>p2 <span class="token operator">=</span> p1 <span class="token operator">/</span> <span class="token string">'abc'</span><span class="token keyword">print</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token comment"># 结果</span>E<span class="token punctuation">:</span>\python\a<span class="token punctuation">.</span>pyE<span class="token punctuation">:</span>\python\<span class="token number">123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> Path.cwd()</p><p><code>获取当前路径</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># cwd 顾名思义:current word directory</span>path <span class="token operator">=</span> Path<span class="token punctuation">.</span>cwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token comment"># 结果</span>E<span class="token punctuation">:</span>\python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> Path.stat()</p><p><code>获取当前文件的元数据信息</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'1.py'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 结果</span>os<span class="token punctuation">.</span>stat_result<span class="token punctuation">(</span>st_mode<span class="token operator">=</span><span class="token number">33206</span><span class="token punctuation">,</span> st_ino<span class="token operator">=</span><span class="token number">8444249301448143</span><span class="token punctuation">,</span> st_dev<span class="token operator">=</span><span class="token number">2561774433</span><span class="token punctuation">,</span> st_nlink<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> st_uid<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> st_gid<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> st_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> st_atime<span class="token operator">=</span><span class="token number">1525926554</span><span class="token punctuation">,</span> st_mtime<span class="token operator">=</span><span class="token number">1525926554</span><span class="token punctuation">,</span> st_ctime<span class="token operator">=</span><span class="token number">1525926554</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> Path.exists()</p><p><code>判断当前路径是否是文件或者文件夹</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>Path<span class="token punctuation">(</span><span class="token string">'a.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>Path<span class="token punctuation">(</span><span class="token string">'2.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 结果</span><span class="token boolean">True</span><span class="token boolean">True</span><span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> Path.glob(pattern)与Path.rglob()(pattern)</p><p><code>Path.glob(pattern):获取路径下的所有符合pattern的文件，返回一个generator</code></p><p>目录下的文件如下：</p><p><code>moudel为文件夹 ,a.py,b.py,c.py</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">path <span class="token operator">=</span> Path<span class="token punctuation">.</span>cwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># pys是经过yeild产生的迭代器</span>pys <span class="token operator">=</span> path<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*.py'</span><span class="token punctuation">)</span><span class="token keyword">for</span> py <span class="token keyword">in</span> pys<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>py<span class="token punctuation">)</span><span class="token comment"># 结果</span>E<span class="token punctuation">:</span>\python\a<span class="token punctuation">.</span>pyE<span class="token punctuation">:</span>\python\b<span class="token punctuation">.</span>pyE<span class="token punctuation">:</span>\python\c<span class="token punctuation">.</span>py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Path.rglob(pattern):与上面类似，只不过是返回路径中所有子文件夹的符合pattern的文件。</code></p><p> Path.is_dir()与Path.is_file()</p><p><code>Path.is_dir()判断该路径是否是文件夹</code><br><code>Path.is_file()判断该路径是否是文件</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'p1:'</span><span class="token punctuation">)</span>p1 <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'D:/python'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>is_dir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>is_file<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'p2:'</span><span class="token punctuation">)</span>p2 <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'D:/python/1.py'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>is_dir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>is_file<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#当路径不存在时也会返回Fasle</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'wrong path:'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'D:/NoneExistsPath'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_dir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'D:/NoneExistsPath'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_file<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 结果</span>p1<span class="token punctuation">:</span><span class="token boolean">True</span><span class="token boolean">False</span>p2<span class="token punctuation">:</span><span class="token boolean">False</span><span class="token boolean">True</span>wrong path<span class="token punctuation">:</span><span class="token boolean">False</span><span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> Path.iterdir()</p><p><code>当path为文件夹时，通过yield产生path文件夹下的所有文件、文件夹路径的迭代器</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p <span class="token operator">=</span> Path<span class="token punctuation">.</span>cwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> p<span class="token punctuation">.</span>iterdir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment"># 结果</span>D<span class="token punctuation">:</span>\python\a<span class="token punctuation">.</span>pyD<span class="token punctuation">:</span>\python\b<span class="token punctuation">.</span>pyD<span class="token punctuation">:</span>\python\c<span class="token punctuation">.</span>pyD<span class="token punctuation">:</span>\python\moudle<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Path.mkdir(mode=0o777,parents=Fasle)</p><p><code>根据路径创建文件夹,parents=True时，会依次创建路径中间缺少的文件夹</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p_new <span class="token operator">=</span> p<span class="token operator">/</span><span class="token string">'new_dir'</span>p_new<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span><span class="token punctuation">)</span> p_news <span class="token operator">=</span> p<span class="token operator">/</span><span class="token string">'new_dirs/new_dir'</span>p_news<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span>parents<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Path.open(mode=’r’, buffering=-1, encoding=None, errors=None, newline=None)</p><p><code>类似于open()函数</code></p><p> Path.rename(target)</p><p><code>当target是string时，重命名文件或文件夹</code></p><p><code>当target是Path时，重命名并移动文件或文件夹</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p1 <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'a.py'</span><span class="token punctuation">)</span>p1<span class="token punctuation">.</span>rename<span class="token punctuation">(</span><span class="token string">'new_name.py'</span><span class="token punctuation">)</span> p2 <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'b.py'</span><span class="token punctuation">)</span>target <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'new_dir/new_name.py'</span><span class="token punctuation">)</span>p2<span class="token punctuation">.</span>rename<span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token comment"># 案例自己可以尝试一下</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> Path.replace(target)</p><p><code>重命名当前文件或文件夹，如果target所指示的文件或文件夹已存在，则覆盖原文件</code></p><p> Path.parent(),Path.parents()</p><p><code>parent获取path的上级路径，parents获取path的所有上级路径</code></p><p> Path.is_absolute()</p><p><code>判断path是否是绝对路径</code></p><p> Path.match(pattern)</p><p><code>判断path是否满足pattern</code></p><p> Path.rmdir()</p><p><code>当path为空文件夹的时候，删除该文件夹</code></p><p> Path.name</p><p><code>获取path文件名</code></p><p> Path.suffix</p><p><code>获取path文件后缀</code></p><p>好了今天就和大家分享到这里啦</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pathlib库 </tag>
            
            <tag> Path </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十分钟搞定pandas</title>
      <link href="posts/158338ef.html"/>
      <url>posts/158338ef.html</url>
      
        <content type="html"><![CDATA[<h2><span id="模块导入">模块导入</span></h2><p>首先要学会导入模块，我们会按下面的格式引入所需要的库</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pylot <span class="token keyword">as</span> plt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2><span id="创建对象">创建对象</span></h2><ol><li><p>可以通过传递一个<code>list</code>对象来创建<code>series</code>，<code>pandas</code>会默认创建整形索引。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>nan<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token comment"># 结果</span><span class="token number">0</span>    <span class="token number">1.0</span><span class="token number">1</span>    <span class="token number">3.0</span><span class="token number">2</span>    <span class="token number">5.0</span><span class="token number">3</span>    NaN<span class="token number">4</span>    <span class="token number">6.0</span><span class="token number">5</span>    <span class="token number">8.0</span>dtype<span class="token punctuation">:</span> float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过传递一个<code>numpy array</code>,时间索引以及列标签来创建一个<code>DataFrame</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 时间</span>dates <span class="token operator">=</span> pd<span class="token punctuation">.</span>date_range<span class="token punctuation">(</span><span class="token string">'20130101'</span><span class="token punctuation">,</span>periods<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment"># randn函数返回一个或一组样本，具有标准正态分布。</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>index<span class="token operator">=</span>dates<span class="token punctuation">,</span>columns<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">'ABCD'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 结果</span>                   A         B         C         D<span class="token number">2013</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span>  <span class="token number">1.471985</span> <span class="token operator">-</span><span class="token number">0.406890</span> <span class="token operator">-</span><span class="token number">0.750888</span>  <span class="token number">0.097701</span><span class="token number">2013</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">02</span>  <span class="token number">0.936148</span> <span class="token operator">-</span><span class="token number">0.611786</span>  <span class="token number">0.874373</span>  <span class="token number">0.686399</span><span class="token number">2013</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">03</span> <span class="token operator">-</span><span class="token number">0.422098</span>  <span class="token number">0.181850</span>  <span class="token number">0.769788</span>  <span class="token number">1.248009</span><span class="token number">2013</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">04</span>  <span class="token number">0.063412</span>  <span class="token number">0.573801</span> <span class="token operator">-</span><span class="token number">0.168527</span> <span class="token operator">-</span><span class="token number">0.428844</span><span class="token number">2013</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">05</span> <span class="token operator">-</span><span class="token number">0.143370</span>  <span class="token number">0.649602</span>  <span class="token number">1.022139</span>  <span class="token number">1.095653</span><span class="token number">2013</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">06</span> <span class="token operator">-</span><span class="token number">0.241681</span> <span class="token operator">-</span><span class="token number">0.466754</span>  <span class="token number">0.012117</span> <span class="token operator">-</span><span class="token number">0.766723</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="3"><li><p>通过传递一个能够被转换成类似序列结构的字典对象来创建一个<code>DataFrame</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># dict</span>df2 <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span>                    <span class="token string">'B'</span><span class="token punctuation">:</span>pd<span class="token punctuation">.</span>Timestamp<span class="token punctuation">(</span><span class="token string">'20210226'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'C'</span><span class="token punctuation">:</span>pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dtype<span class="token operator">=</span><span class="token string">'float32'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'D'</span><span class="token punctuation">:</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'E'</span><span class="token punctuation">:</span>pd<span class="token punctuation">.</span>Categorical<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token string">"train"</span><span class="token punctuation">,</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token string">"train"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'F'</span><span class="token punctuation">:</span><span class="token string">'foo'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment"># 结果</span>     A          B    C  D      E    F<span class="token number">0</span>  <span class="token number">1.0</span> <span class="token number">2021</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">26</span>  <span class="token number">1.0</span>  <span class="token number">3</span>   test  foo<span class="token number">1</span>  <span class="token number">1.0</span> <span class="token number">2021</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">26</span>  <span class="token number">1.0</span>  <span class="token number">3</span>  train  foo<span class="token number">2</span>  <span class="token number">1.0</span> <span class="token number">2021</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">26</span>  <span class="token number">1.0</span>  <span class="token number">3</span>   test  foo<span class="token number">3</span>  <span class="token number">1.0</span> <span class="token number">2021</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">26</span>  <span class="token number">1.0</span>  <span class="token number">3</span>  train  foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="4"><li><p>查看不同列的数据类型</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>df2<span class="token punctuation">.</span>dtypes<span class="token punctuation">)</span>A           float64B    datetime64<span class="token punctuation">[</span>ns<span class="token punctuation">]</span>C           float32D             int32E          categoryF            <span class="token builtin">object</span>dtype<span class="token punctuation">:</span> <span class="token builtin">object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="补充知识点">补充知识点</span></h2></li></ol><p><code>pd.Categorical()</code>这个方法，大家很少见吧！现在把自己的理解清晰的给正在疑惑的小伙伴说明一下！</p><p>首先定义一个列表</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在我们来使用Categorical方法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ss <span class="token operator">=</span> pd<span class="token punctuation">.</span>Categorical<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token comment"># 结果</span>Categories <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印<code>ss</code>之后我们发现 <code>Categories (5, object): ['a', 'b', 'c', 'd', 'e']</code>把我们的重复值去掉了，原来有6个现在才有5个，那么其余的是不是不在了呢？</p><p>答案是：其余还在，只不过使用了另外一个表示方式！</p><p>我们现在来查看一下他是什么数据类型</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>ss<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token comment"># 结果</span>category<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们再来看下<code>ss</code>的两个特别重要的属性</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>ss<span class="token punctuation">.</span>codes<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ss<span class="token punctuation">.</span>categories<span class="token punctuation">)</span><span class="token comment"># 结果</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span>Index<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'object'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过对比，细心的你，应该发现，原来的字母现在已经被数字所代替，而且用的是从0开始的索引，所以a对应0遇到重复的a同样用0表示，这样就可以把非数值的转换成数值的，方便计算！我觉得这就是这个方法的最大好处！</p><p><code>pd.Categorical( list ).codes</code> 这样就可以直接得到原始数据的对应的序号列表，通过这样的处理可以将类别信息转化成数值信息 ，这样就可以应用到模型中去了</p><p>至于categories属性，可以看到原来的字母的去重后的情况！用处不大，主要还是codes比较实用</p>]]></content>
      
      
      <categories>
          
          <category> pandas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python编译exe文件</title>
      <link href="posts/65f8480c.html"/>
      <url>posts/65f8480c.html</url>
      
        <content type="html"><![CDATA[<h2><span id="目的描述">目的描述</span></h2><p>为了让没有安装Python的人也能使用我们编写的.py文件，我们需要将编写好的Python程序生成.exe文件。</p><h2><span id="下载pyinstaller">下载pyinstaller</span></h2><p>pyinstaller插件是Python自带的插件，用于为我们写好的代码进行打包，最终自动合成.exe文件。</p><p>在Pycharm界面的最下面，你可以看到Terminal，选择这个选项，这就是一个终端界面。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/20210225221218.png" alt="安装pyinsatller"></p><p>在此界面写输入指令： <strong>pip install pyinstaller</strong> 对pyinstaller进行下载。</p><p>常见错误解决方案：</p><ol><li>错误：<code>You are using pip version 10.0.1, however version 20.0.2 is available. You should consider upgrading via the ‘python -m pip install --upgrade pip’ command. </code>解决方案：升级pip，输入指令：‘python -m pip install –upgrade pip’</li><li>错误：<code>使用指令 python -m pip install --upgrade pip 升级pip时，Pycharm报错：AttributeError: ‘NoneType’ object has no attribute ‘bytes’</code>.解决方案: 输入指令：easy_install -U pip</li></ol><h2><span id="使用pyinstaller">使用pyinstaller</span></h2><p>在终端里输入的指令为： <code>pyinstaller -w -F XXX.py</code></p><p>但是对于初学者来说，这里要解释的东西很多：<br>-w：表示希望在生成的.exe程序运行过程中，不要出现cmd黑框（就是图中的黑框）（注意：小写！）</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/a181c493b7995748a52cfb4a7b655f96.png" alt="黑框"></p><p>-F：表示希望将所有的程序全部打包在一起，生成的只有一个.exe文件，这样的文件集成度高，但是运行速度慢；如果不写-F，生成的还有一堆.dll文件，这样的程序里文件很多，但是运行速度比较快，这也是我们平时使用的程序的样式（如图）（注意：大写！）</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/211efd15cfc51a2d6b2681d2f1d9053e.png" alt="不写-F的情况"></p><p>XXX.py：指的是你整个项目的入口程序，大家写项目时很可能是多文件编程，你整个项目时靠哪个文件作为入口拉起来的，就填那个文件的名字。</p><p>常见问题以及解决方案</p><p>问题：<code>ValueError: script ‘C:\Users\Administrator.XXX.py’ not found</code>指的是找不到XXX.py这个程序</p><p>解决办法：pyinstaller找文件的方法是看你建立的那个工程文件夹里有没有你写进去的文件，而不是看子文件夹里有没有。如果您是在子文件夹中写程序，可以把你写的所有程序都拷贝到工程文件夹中。如果你在代码中导入了图片、文档等与路径相关的文件，注意修改路径。</p><h2><span id="找到生成的exe文件">找到生成的.exe文件</span></h2><p>没看见就对了，因为.exe文件根本不在工程文件夹下面。运行pyinstaller -w -F XXX.py指令后，会生成两个文件夹：一个叫build，另一个叫dist。<br><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/741a8b293dd7ebceb7775350577a9d44.png" alt="文件夹展示"><br>点开dist文件夹，里面会有一个用你填进去的XXX命名的文件夹，再点进去，你就会看到XXX.exe文件。<br><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/6c1299f8cca49fc893ba787a49a4ed43.png" alt="文件夹展示"><br>理论上你已经生成了.exe可执行文件，这样就完成了。如果你的.exe文件可以运行起来，那么恭喜你！但是实施情况是，这个.exe文件运行起来很有可能会有各种各样奇葩的问题：比如闪退、双击后直接消失了、程序莫名其妙地崩掉等。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python编译exe文件 </tag>
            
            <tag> python第三方库使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多人协作开发</title>
      <link href="posts/11c5853f.html"/>
      <url>posts/11c5853f.html</url>
      
        <content type="html"><![CDATA[<h4><span id="多人协作开发实现步骤">多人协作开发实现步骤</span></h4><ol><li><p>由张三上传一个基本版本到张三的github远程库master上。</p></li><li><p>李四登录github账户访问remoteb版本库。fork  将张三的版本转载到李四的个人github中。</p></li><li><p>李四：在github上新建一个分支dev  本地库中也得新建一个dev分支</p></li><li><p>李四：将本地库的dev分支和远程库的dev分支进行关联</p></li></ol><h4><span id="本地库连接远程">本地库连接远程</span></h4><pre><code>1. github注册账户2. 创建远程版本库3. 本地库和远程库进行关联 </code></pre><pre class="line-numbers language-none"><code class="language-none">git remote -v    git remote add origin git@github.com:pythonde/remoteRepository.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>更新本地库<pre class="line-numbers language-none"><code class="language-none">git pull --rebase origin master    git status    git add hello.py    git commit -m '描述信息'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>将本地库内容上传至远程库</li></ol><pre class="line-numbers language-none"><code class="language-none">git push -u origin master    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git多协议方式</title>
      <link href="posts/558409fe.html"/>
      <url>posts/558409fe.html</url>
      
        <content type="html"><![CDATA[<h4><span id="git支持多协议方式">Git支持多协议方式</span></h4><pre><code>Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令。但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</code></pre><h4><span id="加密方式">加密方式</span></h4><ol><li><p>对称加密：性能高</p><pre class="line-numbers language-none"><code class="language-none">   用什么加密就用什么解密（异或）'123'^'456'---&gt;'4321432'   加密'4321432'^'456'---&gt;'123'   解密<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>非对称加密：安全性高（支付宝采用下面加密方式）</p><pre><code> 公钥加密，私钥解密</code></pre><pre class="line-numbers language-none"><code class="language-none"> 客户端：服务器端：服务器端的公钥             服务器端的私钥客户端的私钥               客户端的公钥<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>SSH密钥对（公钥+私钥）   </p><p> 客户端：git很简单-密钥配对（验证用户时使用SSH），git服务器会随机生成一个对称的密钥。</p><p> 发给客户端，客户端通过对称的密钥对数据传输的时候使用的是对称加密。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git多协议方式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程库和本地库</title>
      <link href="posts/8a4a6d1e.html"/>
      <url>posts/8a4a6d1e.html</url>
      
        <content type="html"><![CDATA[<p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。<br>    github网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p><pre><code>github官网：https://github.com/</code></pre><h4><span id="远程库">远程库</span></h4><pre><code>1. github版本库即为远程库。</code></pre><h4><span id="本地库">本地库</span></h4><pre><code>1. 本地创建的Git版本库即为本地库。</code></pre><h4><span id="使用说明">使用说明</span></h4><pre><code>1. 先在github官网中注册账户。2. 创建SSH key。    由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的。    Windows下打开Git Bash，创建SSH key。    $ ssh-keygen -t rsa -C "youremail@example.com"3. 在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件（密钥对）。    用户主目录：C:\Users\Administrator4. 登陆GitHub，打开"Account settings"，"SSH Keys"页面。5. 点"Add SSH Key"，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。</code></pre><p>​     </p><h4><span id="本地库-关联-远程库">本地库 关联 远程库</span></h4><pre><code>origin:默认远程库名称</code></pre><pre class="line-numbers language-none"><code class="language-none"># 在本地库当前分支    $ git remote add origin git@github.com:pythonde/newRepository.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4><span id="上传数据到远程库">上传数据到远程库</span></h4><pre class="line-numbers language-none"><code class="language-none">$ git push -u origin devThe authenticity of host 'github.com (13.250.177.223)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com,13.250.177.223' (RSA) to the list of known hosts.To github.com:pythonde/newRepository.git ! [rejected]        master -&gt; master (fetch first)error: failed to push some refs to 'git@github.com:pythonde/newRepository.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="远程库更新本地库">远程库更新本地库</span></h4><pre class="line-numbers language-none"><code class="language-none">$ git pull --rebase origin devFrom github.com:pythonde/newRepository * branch            dev        -&gt; FETCH_HEADFirst, rewinding head to replay your work on top of it...Applying: first addApplying: dev secondApplying: test2 dev third<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="成功将本地库内容上传到远程库">成功将本地库内容上传到远程库</span></h4><pre class="line-numbers language-none"><code class="language-none">$ git push -u origin devCounting objects: 9, done.Delta compression using up to 4 threads.Compressing objects: 100% (7/7), done.Writing objects: 100% (9/9), 852 bytes | 852.00 KiB/s, done.Total 9 (delta 0), reused 0 (delta 0)To github.com:pythonde/newRepository.git   a69bffd..da7dd11  dev -&gt; devBranch 'dev' set up to track remote branch 'dev' from 'origin'.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="注意事项">注意事项</span></h4><pre><code>1. 远程操作git push / git pull 时，本地库和远程库分支名相同。2. 第一次push时：$ git push -u origin dev3. 之后只需要简写：$ git push  origin dev4. 远程库分支之间的合并，创建一个pull request进行合并。</code></pre><h4><span id="查看远程库信息">查看远程库信息</span></h4><pre><code>$ git remote -v </code></pre><h4><span id="删除连接远程库">删除连接远程库</span></h4><pre><code>$ git remote rm origin</code></pre><h4><span id="从远程库下载源码到本地库">从远程库下载源码到本地库</span></h4><pre><code>$ git clone git@github.com:pythonde/newRepository.git</code></pre><p>​    </p><p>​<br>​</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git远程库和本地库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分支管理</title>
      <link href="posts/3669e061.html"/>
      <url>posts/3669e061.html</url>
      
        <content type="html"><![CDATA[<h4><span id="分支定义">分支定义</span></h4><pre><code>分支可以理解成 独立开发功能的 小房间。</code></pre><h4><span id="分支操作">分支操作</span></h4><pre class="line-numbers language-none"><code class="language-none"># 创建分支    $ git branch 分支名    # 查看分支    $ git branch# 切换分支    $ git checkout 分支名# 创建+切换分支    $ git checkout -b 分支名    # 合并某分支到当前分支    $ git merge 分支名    # 删除某分支    $ git branch -d 分支名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="合并分支解决冲突">合并分支解决冲突</span></h4><pre class="line-numbers language-none"><code class="language-none">当前分支1   分支2 前提分支1和分支2都进行了代码修改。将分支2的内容合并到分支1# 1. 切换到当前分支1    $ git checkout 分支1    # 2. 和分支2进行合并    $ git merge 分支2    # 3. 执行第二步后出现冲突（CONFLICT）    $ git merge dev    Auto-merging hello.py    CONFLICT (content): Merge conflict in hello.py    Automatic merge failed; fix conflicts and then commit the result.# 4. 解决方案：    print 'first'    &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD    print 'master second'    =======    print 'dev second'    &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev    1. 编辑合并分支1和分支2的内容    2. 修改好之后，$ git add 文件名    3. $ git commit -m "描述信息"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git分支管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="posts/caff8000.html"/>
      <url>posts/caff8000.html</url>
      
        <content type="html"><![CDATA[<h4><span id="文件添加操作">文件添加操作</span></h4><pre class="line-numbers language-none"><code class="language-none"># 1. 工作区中创建新文件hello.py    $ vi hello.py# 2. 查看文件状态    $ git status# 3. 将源码拷贝到暂存区    $ git add hello.py# 4. 将暂存区移动到当前分支    $ git commit -m "创建新文件hello.py"# 5. 查看状态    $ git status    On branch master    nothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="文件删除操作">文件删除操作</span></h4><pre class="line-numbers language-none"><code class="language-none"># 1. 删除工作区中的文件    rm hello.py     # 2. 删除暂存区中的文件    git rm hello.py# 3. 删除当前分支中的文件    git commit -m '描述信息'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="文件修改操作">文件修改操作</span></h4><pre class="line-numbers language-none"><code class="language-none"># 修改文件    $ vi hello.py# 查看状态    $ git status# 添加暂存区    $ git add hello.py    # 添加版本库    $ git commit -m '描述信息'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="文件撤销操作">文件撤销操作</span></h4><pre class="line-numbers language-none"><code class="language-none"># 查看工作区和版本库里面最新版本的区别    $ git diff HEAD -- hello.py    方式1：可以撤销未被追踪的文件    # 丢弃工作区的修改    $ git checkout -- hello.py    方式2：可以撤销到任意版本    # 查看操作日志    $ git log    commit c4e993ddb36d77710dad2c7c8c18130f9a761946 (HEAD -&gt; master)    $ git log --oneline    c4e993d (HEAD -&gt; master) first add        # 回退到某个版本1    $ git reset c4e993ddb36d77710dad2c7c8c18130f9a761946        # 回退到某个版本2    $ git reset --hard c4e993ddb36d77710dad2c7c8c18130f9a761946    #回退到上一个版本    git reset HEAD            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建版本库</title>
      <link href="posts/3ca287b3.html"/>
      <url>posts/3ca287b3.html</url>
      
        <content type="html"><![CDATA[<h4><span id="创建版本库">创建版本库</span></h4><pre class="line-numbers language-none"><code class="language-none"># 创建文件夹    $ mkdir test# 进入当前目录    $ cd test# 查看目录    $ pwd# 将当前目录变成Git可管理的版本库又名仓库，英文名repository    $ git init    Initialized empty Git repository in D:/Tools/Git/test/.git/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git创建版本库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git名词解释</title>
      <link href="posts/6725a818.html"/>
      <url>posts/6725a818.html</url>
      
        <content type="html"><![CDATA[<h4><span id="工作区">工作区</span></h4><pre><code>存放源码的文件夹。</code></pre><h4><span id="版本库">版本库</span></h4><pre><code>版本库又名仓库，英文名repository。这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪。以便任何时刻都可以追踪历史，或者在将来某个时刻可以"还原"。通过"git init"命令创建。".git"隐藏目录就是版本库。</code></pre><h4><span id="暂存区">暂存区</span></h4><pre><code>".git"目录下有一个"index"/"stage"的文件即暂存区。</code></pre><h4><span id="分支">分支</span></h4><pre><code>默认情况下，Git会自动为我们创建一个主分支（master）。".git"下有个名为"HEAD"的文件指向master分支。最新版本代码需要更新到"当前分支"。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git名词解释 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git下载和安装</title>
      <link href="posts/aadc9cb4.html"/>
      <url>posts/aadc9cb4.html</url>
      
        <content type="html"><![CDATA[<h4><span id="git下载安装">Git下载安装</span></h4><pre><code>windows版本下载地址:https://git-scm.com/download/win</code></pre><h4><span id="使用前准备">使用前准备</span></h4><pre><code>1. 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，弹出命令行窗口，说明Git安装成功。2. 安装Git之后，你要做的第一件事情就是去配置你的名字和邮箱，因为每一次提交都需要这些信息。</code></pre><pre class="line-numbers language-none"><code class="language-none">$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git下载和安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集中式和分布式</title>
      <link href="posts/7ee53739.html"/>
      <url>posts/7ee53739.html</url>
      
        <content type="html"><![CDATA[<h4><span id="集中式版本控制软件">集中式版本控制软件</span></h4><ol><li>集中式代表：SVN</li><li>集中式特点：<ol><li>版本库是集中存放在中央服务器的。</li><li>必须实时联网才能工作。</li></ol></li></ol><h4><span id="分布式版本控制软件">分布式版本控制软件</span></h4><ol><li>分布式代表：Git</li><li>分布式特点：<ol><li>个人电脑都可以作为版本库。</li><li>速度快，使用简单。</li><li>不必实时联网。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集中式和分布式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git_简介</title>
      <link href="posts/6814ac35.html"/>
      <url>posts/6814ac35.html</url>
      
        <content type="html"><![CDATA[<h4><span id="git简介">Git简介</span></h4><pre><code>Git是一个分布式版本控制软件。</code></pre><h4><span id="背景故事">背景故事</span></h4><pre><code>Linus在1991年创建了开源的Linux。在2002年以前：世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后Linus本人通过手工方式合并代码。2002年-2004年：（商用版本控制软件）BitKeeper的东家BitMover公司授权Linux社区免费使用这个版本控制系统。2005年：Linus花了两周时间自己用C写了git（一个分布式版本控制软件）。2008年：GitHub网站上线了，它为开源项目免费提供Git存储。</code></pre><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm永久破解方法</title>
      <link href="posts/75f55e54.html"/>
      <url>posts/75f55e54.html</url>
      
        <content type="html"><![CDATA[<p>今天有小伙伴问到<code>PyCharm</code>专业版到期了怎么办，今天我们来聊一聊如何攻破<code>PyCharm 2020.1版本</code>！</p><h2><span id="一-下载破解的补丁">一 . 下载破解的补丁</span></h2><p>破解补丁请到我的GitHub自取。</p><p>下载补丁文件 <code>jetbrains-agent.jar</code> 和<code>importat.txt</code>文件并将它放置到 <code>PyCharm</code>安装目录的/lib目录下（或者是/bin文件夹下）</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/1298173-20200404170153307-128831857.png" alt="文件存放的位置"></p><h2><span id="二-点击试用">二 . 点击试用</span></h2><p>进入<code>PyCharm</code>软件界面后，点击激活窗口的“Evaluate for free”免费试用。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/%E7%82%B9%E5%87%BB%E8%AF%95%E7%94%A8.png" alt="点击试用"></p><h2><span id="三-修改配置文件">三 . 修改配置文件</span></h2><blockquote><p><strong>配置文件修改不能在bin目录下直接修改，而是通过<code>PyCharm</code>修改！</strong></p><p><font size="3" face="arial" color="red">必须通过软件里面修改，若是修改安装文件会导致破解失败！</font></p></blockquote><p>进入到项目界面后，点击<code>Pycharm</code>最上面的菜单栏中的 “Help” -&gt; “Edit Custom VM Options …”。 </p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/20191228091658361.png" alt="Edit Custom VM Options... "></p><p>在打开的<code>vmoptions</code>编辑窗口末行添加：<code>-javaagent:你pycharm的安装目录\lib\jetbrains-agent.jar</code></p><p><font size="3" face="arial" color="red">建议直接复制粘贴，格式千万注意！</font></p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/1298173-20200404170707515-288476913.png" alt="编辑展示"></p><p>最后一步也是最重要的事情，重复三遍否则可能会破解失败</p><p><font size="5" face="arial" color="red">修改完配置文件之后重启Pycharm</font></p><p><font size="5" face="arial" color="red">修改完配置文件之后重启Pycharm</font></p><p><font size="5" face="arial" color="red">修改完配置文件之后重启Pycharm</font></p><h2><span id="四-问题解决办法">四 . 问题解决办法</span></h2><p>如果错误则会出现<code>PyCharm</code>打不开的情况，不要着急。</p><p>打开上图的文件（你<code>PyCharm</code>的安装目录\bin），找到pycharm64.exe.vmoptions这个文件.</p><p><font size="5" face="arial" color="red">看看最后一行有没有你刚刚加入的代码！！</font></p><p>再看看你刚才添加的目录是否有问题，建议直接复制粘贴下面的代码：</p><p><strong>-javaagent:你pycharm的安装目录\lib\jetbrains-agent.jar</strong></p><p>一般打不开都是这个原因！</p><p>还有一种方法是，使用了软件一段时候破解然后打不开的：</p><p>这时候可以删除用户配置目录下的<code>PyCharm</code>文件夹<code>(能打开PyCharm就不要删除)</code>：</p><p><code>PyCharm</code>文件夹<strong>，</strong>注意这个文件夹是隐藏目录！</p><blockquote><p><code>windwos：C:\Users\用户名\</code><br><code>macos：~/Library/Preferences/</code><br><code>ubuntu：~/.</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/20191228095203793.png" alt="文件位置"></p><h2><span id="五-输入激活码">五 . 输入激活码</span></h2><p>打开软件上方：Help-&gt;Register页面。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/20191228092948451.png" alt="输入激活码"></p><p>点击OK之后，查看有效期。</p><p>点击上方：Help -&gt; About。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/20191228095545228.png" alt="测试结果"></p><p>如果激活码不行的话，可以试一试服务器激活！</p><p>这里我们选用服务器激活，打开如下页面(Help-&gt;Register)。</p><blockquote><p>点击License server，然后输入<a href="https://fls.jetbrains-agent.com/">https://fls.jetbrains-agent.com</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/1298173-20200331152734685-388035428.png" alt="服务器激活"></p><p>点击Activate，查看有效期。</p><p>点击上方：Help-&gt;About。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/20191228095545228.png" alt="测试结果"></p><h2><span id="六-弹窗问题解决">六 . 弹窗问题解决</span></h2><p>如果每次打开<code>PyCharm</code>都会出现一个弹窗，则是因为<code>import.txt</code>丢失，只需要将<code>import.txt</code>再次放进去即可。</p>]]></content>
      
      
      <categories>
          
          <category> 软件破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyCharm永久破解方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序算法</title>
      <link href="posts/ff8068c0.html"/>
      <url>posts/ff8068c0.html</url>
      
        <content type="html"><![CDATA[<h1><span id="python快速排序算法">Python快速排序算法</span></h1><h2><span id="一-快速排序算法的基本思想">一 . 快速排序算法的基本思想</span></h2><p>快速排序又被称为划分交换排序，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两个数据分别进行快速排序，整个排序的过程可以递归进行，以此达到整个数据变成有序的序列。</p><p>快速排序的分治法的实现类似于<code>Hadoop</code>的<code>Mapreduce</code>的分而治之的思想以及分区操作在<code>Hadoop</code>中也有分区、排序、合并操作。<code>Hadoop</code>大数据技术我会在以后的出一个专题系列。</p><ol><li><p>从数列中挑选出一个元素，我们称之为“基准”。</p></li><li><p>重新排列数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆放在基准值的后边(相同的数值可以放到任意一边)。在这个分区结束之后，该基准就处于数列的中间位置。这个称之为分区操作。</p></li><li><p>递归地把小于基准值的元素子数列和大于基准值元素的子数列排序。</p></li><li><p>递归的最底部情形，是数列的大小是零或者是一，也就是永远都已经被排好序。虽然一直递归下去，但这个算法总归会结束，因为在每次迭代的过程中，他至少会把一个元素摆到它最后的位置去。</p><p>是不是很抽象啊，接下来我们看下这张图片，或许就会有些许理解了。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg/source/20190331172055940.jpg" alt="快速排序"></p></li></ol><h2><span id="二-快速排序的特点">二 . 快速排序的特点</span></h2><p>​    <code>速度快</code></p><h2><span id="三-算法关键点">三 . 算法关键点</span></h2><ol><li>确定作为基准元素的位置，取一个元素p<code>我们不妨取第一个元素</code>，使得元素p归位<code>序列p前的元素都比p小，p后的都比p大</code>。</li><li>列表被元素p分成两部分，左边的都比p小，右边的都比p大。</li><li>递归完成排序</li></ol><h2><span id="四-实现代码">四 . 实现代码</span></h2><p>快速排序的伪代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># encoding=utf-8</span><span class="token comment"># Time : 2021/2/16 20:11 </span><span class="token comment"># Author : 啵啵</span><span class="token comment"># File : quick_sort.py </span><span class="token comment"># Software: PyCharm</span><span class="token keyword">from</span> cal_time <span class="token keyword">import</span> cal_time<span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>    temp <span class="token operator">=</span> li<span class="token punctuation">[</span>left<span class="token punctuation">]</span>    <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        <span class="token comment"># 从右边找比tmp小的数</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right <span class="token keyword">and</span> li<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> temp<span class="token punctuation">:</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 如果右边的值比基准值小，则把右边的值写到左边的空位置上</span>        li<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>right<span class="token punctuation">]</span>        <span class="token keyword">while</span>  left <span class="token operator">&lt;</span> right <span class="token keyword">and</span> li<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">:</span>            left <span class="token operator">+=</span><span class="token number">1</span>        <span class="token comment"># 如果左边的值比基准值小，则把左边的值写到右边的空位置上</span>        li<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>left<span class="token punctuation">]</span>    <span class="token comment"># temp归位</span>    <span class="token comment"># 当left和right下标相等时，说明此趟排序完成</span>    <span class="token comment"># 这里写left和right都一样，因为他们相遇值一样</span>    li<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> temp    <span class="token keyword">return</span> left<span class="token keyword">def</span> <span class="token function">_quick_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 至少两个元素</span>    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        mid <span class="token operator">=</span> partition<span class="token punctuation">(</span>li<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>        _quick_sort<span class="token punctuation">(</span>li<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        _quick_sort<span class="token punctuation">(</span>li<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token decorator annotation punctuation">@cal_time</span><span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    _quick_sort<span class="token punctuation">(</span>li<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码讲解:</p><p>快速排序算法相对来说比较困难，直接把注释写到代码旁边了。</p><p>大家注意到了没，为什么写了<code>_quick_sort</code>还要再写到quick_sort内执行，因为使用了装饰器，<code>_quick_sort</code>是一个递归函数，则装饰器会在每次函数调用时返回一个结果。我们是想求得整个排序耗费时间而不是每一趟的时间。如果数据量过小，需要提高装饰器的精度才能显示时间，否则只能显示0秒，排序速度太快哈哈哈。</p><h2><span id="五-运行测试">五 . 运行测试</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">li <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"要排序的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span>quick_sort<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序后的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 结果:</span><span class="token comment"># 要排序的列表:[3, 4, 2, 1, 5, 6, 8, 9]</span><span class="token comment"># 排序后的列表:[1, 2, 3, 4, 5, 6, 8, 9]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="六-时间复杂度">六 . 时间复杂度</span></h2><ul><li>最优时间复杂度：<code>O(nlogn)</code></li><li>最坏时间复杂度：O(n<sup>2</sup>)</li><li>稳定性：不稳定</li></ul><p>从一开始快速排序平均需要花费<code>O(nlogn)</code>时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用<code>O(n)</code>的时间。在使用结合（concatenation）的版本中，这项运算也是<code>O(n)</code>。</p><p>在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作<code>logn</code>次嵌套的调用。这个意思就是调用树的深度是<code>O(logn)</code>。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要<code>O(n)</code>的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有<code>O(n)</code>个调用，这些被归纳在O(n)系数中。结果是这个算法仅需使用<code>O(nlogn)</code>时间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python算法 </tag>
            
            <tag> python数据结构 </tag>
            
            <tag> 快速排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序算法</title>
      <link href="posts/96555fb2.html"/>
      <url>posts/96555fb2.html</url>
      
        <content type="html"><![CDATA[<center> 在这里bobo祝大家新年快乐！！</center><h1><span id="python插入排序算法">Python插入排序算法</span></h1><h2><span id="一-插入排序算法的基本思想">一 . 插入排序算法的基本思想</span></h2><p>​    在这里我先举一个小例子，帮助大家理解插入排序算法，就比如现在有一副扑克牌放在桌子上，我们只能看到牌的背面，现在我们一次拿出一张牌，放到手中，依次取若干张，在每取一次牌，我们就插入到手里的牌中，始终保持手中的牌是有序的。</p><ol><li><p>插入排序是指在待排序的元素中，假设前面n-1(其中n&gt;=2)个数已经是排好顺序的。</p></li><li><p>现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。</p></li><li><p>按照此法对所有元素进行插入，直到整个序列排为有序的过程。</p><p>下面我们来看一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/bVbswgT" alt="插入排序"></p></li></ol><hr><h2><span id="二-算法关键点">二 . 算法关键点</span></h2><ol><li>有序区和无序区。</li><li>待插入数值与有序区的比较过程。</li><li>最终确定待插入数值的插入位置。</li></ol><hr><h2><span id="三-实现代码">三 . 实现代码</span></h2><p>​    插入排序的伪代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># encoding=utf-8</span><span class="token comment"># Time : 2021/2/12 20:07 </span><span class="token comment"># Author : 啵啵</span><span class="token comment"># File : insert_sort.py </span><span class="token comment"># Software: PyCharm</span><span class="token comment"># 插入排序算法</span><span class="token keyword">def</span> <span class="token function">insert_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># i表示摸到的牌的下标</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        temp <span class="token operator">=</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment"># j指的是手里的牌的下标</span>        j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token keyword">and</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">:</span>            li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j <span class="token operator">-=</span><span class="token number">1</span>        li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码讲解：</p><ol><li>第一层for循环是决定插入排序算法的趟数，因为有序区只有一个数时，这个数即为最大，不需要进行插入排序，所以下标从1开始算，与有序区的那个数进行比较。</li><li>temp用于临时存储抽取到的数。</li><li>while循环需要确保取到的数与无序的数进行比较并且一旦抽取到的数比有序区的某个数就结束循环。</li><li>li[j+1] = temp这行代码是将抽取到的数插入到正确的位置。</li></ol><p>​    插入排序算法思路相比于冒泡排序算法和选择排序算法有一点难度，重点是要把握好无序区，有序区，位置交换这三点。</p><hr><h2><span id="四-时间复杂度">四 . 时间复杂度</span></h2><p>​    涉及两层循环则时间复杂度为：O(n<sup>2</sup>)</p><hr><h2><span id="五-运行测试">五 . 运行测试</span></h2><p>​    </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">li <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"要排序的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span>insert_sort<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序后的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 结果：</span><span class="token comment"># 要排序的列表:[3, 4, 2, 1, 5, 6, 8, 9]</span><span class="token comment"># 排序后的列表:[1, 2, 3, 4, 5, 6, 8, 9]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插入排序算法 </tag>
            
            <tag> python算法 </tag>
            
            <tag> python数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序算法</title>
      <link href="posts/43d00a99.html"/>
      <url>posts/43d00a99.html</url>
      
        <content type="html"><![CDATA[<center> 在这里bobo预祝大家新年快乐！！</center><h1><span id="python选择排序算法">Python选择排序算法</span></h1><h2><span id="一-选择排序算法的基本思想">一  . 选择排序算法的基本思想</span></h2><ol><li><p>一趟排序记录最小的数，放到第一个位置。</p></li><li><p>再一趟排序记录列表无序区最小的数，放到第二个位置，直至排序全部依次完成。</p><p>我们来看一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/bVbswmI" alt="选择排序"></p></li></ol><hr><h2><span id="二-算法关键点">二 . 算法关键点</span></h2><ol><li> 有序区和无序区。</li><li> 无序区最小数的位置。</li></ol><hr><h2><span id="三-实现代码">三 . 实现代码</span></h2><p>​    首先看一种比较简单容易理解的选择排序算法思路：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">select_sort_simple</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    li_new <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        min_value <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span>        li_new<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min_value<span class="token punctuation">)</span>        li<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>min_value<span class="token punctuation">)</span>    <span class="token keyword">return</span> li_new<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>性能优化前的实现思路：</p><p>​    通过建立两个列表，使用列表的append方法和remove方法实现数据的排序。</p><p>代码弱点：</p><p>​    <code>但是大家可以仔细想一下，这种算法需要开辟两块内存区域来存放列表，一块保存原数据，另一块保存排序后的数据，假如数据量基数比较大时，这无疑是致命。</code></p><p>​    比较难理解但是效率较高的选择排序算法思路：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">select_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        mic_loc <span class="token operator">=</span> i        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span><span class="token punctuation">:</span>                min_loc <span class="token operator">=</span> j            li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>性能优化后的实现思路：</p><p>​    通过建立单个列表，然后利用列表的下标来替换相对应位置的元素。</p><p>代码讲解：</p><ol><li> 第一层for循环决定选择排序算法的趟数。因为只剩最后一个数时，列表则不需要再次进行排序，所以len(li) - 1。</li><li> min_loc是一个标志位，最小值的下标。默认是无序区的第一个数。</li><li>第二层for循环是无序区相邻两个数进行比较，min_loc标志位保持为较小的数的下标。</li><li>无序区最小值移动到无序区的第一个，此轮循环结束，无序区的个数减一，有序区的个数加一。</li></ol><p>代码优点：</p><p>​    <code>select_sort选择排序算法，只使用了一块内存区域用于存储列表，减小内存的开销。</code></p><p>时间复杂度：</p><p>O(n<sup>2</sup>)</p><h2><span id="四-代码优化">四 . 代码优化</span></h2><p>​    如果无序区的比较一趟之后，第一个数依然是最小的数，则不需要发生位置交换。优化后代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">select_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        min_loc <span class="token operator">=</span> i        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span><span class="token punctuation">:</span>                min_loc <span class="token operator">=</span> j        <span class="token keyword">if</span> min_loc <span class="token operator">!=</span> i<span class="token punctuation">:</span>            li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="五-运行测试">五 . 运行测试</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">li <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"要排序的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span>select_sort<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序后的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 结果：</span><span class="token comment"># 要排序的列表:[3, 4, 2, 1, 5, 6, 8, 9]</span><span class="token comment"># 排序后的列表:[1, 2, 3, 4, 5, 6, 8, 9]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python算法 </tag>
            
            <tag> python数据结构 </tag>
            
            <tag> 选择排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序算法</title>
      <link href="posts/4d081371.html"/>
      <url>posts/4d081371.html</url>
      
        <content type="html"><![CDATA[<h1><span id="python冒泡排序算法">Python冒泡排序算法</span></h1><h2><span id="一-冒泡排序算法的基本思想">一  . 冒泡排序算法的基本思想</span></h2><ol><li><p>列表每两个相邻的数，如果前面的比后边的数大，则交换这两个数。</p></li><li><p>一趟排序完成之后，则无序区减少一个数，有序区增加一个数。（无序区是为完成排序的数，有序区是已经完成排序的数。）</p><p>下面我们来看一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt="冒泡排序"></p></li></ol><hr><h2><span id="二-代码关键点">二  . 代码关键点</span></h2><ol><li>趟数的概念</li><li>无序区的范围的变化</li></ol><hr><h2><span id="三-实现代码">三  . 实现代码</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                li<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码讲解：</p><ul><li>li是需要排序的列表。</li><li>第一层for循环一共需要遍历多少趟来回，因为最后只剩一个数时，不需要再遍历，则len(li) - 1。</li><li>第二层for循环时一共需要多少趟相邻数据比较，例如：长度为五的列表（下标从零开始）第零趟无序区的数的个数为零，则需要执行四趟，因为第四个数是和第五个数进行比较，比较完成时，最大值已经出现，就不需要再比较。</li><li>列表交换数据。</li></ul><h2><span id="四-时间复杂度">四 . 时间复杂度</span></h2><p>​    因为两层for循环，所以时间复杂度是O(n<sup>2</sup>)</p><h2><span id="五-性能优化">五 . 性能优化</span></h2><p>​    如果冒泡排序中的一趟排序没有发生交换，则说明列表已经有序，则可以直接结束算法。</p><h3><span id="解决思路">解决思路</span></h3><p>​    可以通过使用标志位解决。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 最后一次只剩一个数时不用排序</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 第i趟</span>        exchange <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span> <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                li<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                exchange <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> exchange<span class="token punctuation">:</span>            <span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="六-运行测试">六 . 运行测试</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">li <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"要排序的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span>bubble_sort<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序后的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 结果：</span><span class="token comment"># 要排序的列表:[3, 4, 2, 1, 5, 6, 8, 9]</span><span class="token comment"># 排序后的列表:[1, 2, 3, 4, 5, 6, 8, 9]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python算法 </tag>
            
            <tag> python数据结构 </tag>
            
            <tag> 冒泡排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存的穿透、击穿、雪崩</title>
      <link href="posts/56739dcf.html"/>
      <url>posts/56739dcf.html</url>
      
        <content type="html"><![CDATA[<h2><span id="一-缓存处理的过程">一 .  缓存处理的过程</span></h2><p>​    <code>前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。</code></p><hr><h2><span id="二-缓存穿透"><strong>二 . 缓存穿透</strong></span></h2><p>​    <strong>描述</strong></p><p>​    <code>指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。因为缓存和数据库中都没有的数据，但是用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</code></p><p>​    <strong>解决方案</strong></p><ol><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截。</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li></ol><hr><h2><span id="三-缓存击穿">三 . 缓存击穿</span></h2><p>​    <strong>解决方案:</strong></p><ol><li>设置热点数据永远不过期。</li><li>加互斥锁。</li></ol><hr><h2><span id="四-缓存雪崩">四 . 缓存雪崩</span></h2><p>​    <strong>描述</strong></p><p>​    <code>指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机。</code></p><p>​    <strong>与缓存击穿的区别</strong></p><p>​    <code>缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</code></p><p>​    <strong>解决方案</strong></p><ol><li><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p></li><li><p>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</p></li><li><p>设置热点数据永远不过期。</p><p>​</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 缓存问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存雪崩 </tag>
            
            <tag> 缓存穿透 </tag>
            
            <tag> 缓存击穿 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
