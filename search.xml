<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PyCharm永久破解方法</title>
      <link href="posts/75f55e54.html"/>
      <url>posts/75f55e54.html</url>
      
        <content type="html"><![CDATA[<p>今天有小伙伴问到<code>PyCharm</code>专业版到期了怎么办，今天我们来聊一聊如何攻破<code>PyCharm 2020.1版本</code>！</p><h2><span id="一-下载破解的补丁">一 . 下载破解的补丁</span></h2><p>破解补丁请到我的GitHub自取。</p><p>下载补丁文件 <code>jetbrains-agent.jar</code> 和<code>importat.txt</code>文件并将它放置到 <code>PyCharm</code>安装目录的/lib目录下（或者是/bin文件夹下）</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/1298173-20200404170153307-128831857.png" alt="文件存放的位置"></p><h2><span id="二-点击试用">二 . 点击试用</span></h2><p>进入<code>PyCharm</code>软件界面后，点击激活窗口的“Evaluate for free”免费试用。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/%E7%82%B9%E5%87%BB%E8%AF%95%E7%94%A8.png" alt="点击试用"></p><h2><span id="三-修改配置文件">三 . 修改配置文件</span></h2><blockquote><p><strong>配置文件修改不能在bin目录下直接修改，而是通过<code>PyCharm</code>修改！</strong></p><p><font size="3" face="arial" color="red">必须通过软件里面修改，若是修改安装文件会导致破解失败！</font></p></blockquote><p>进入到项目界面后，点击<code>Pycharm</code>最上面的菜单栏中的 “Help” -&gt; “Edit Custom VM Options …”。 </p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/20191228091658361.png" alt="Edit Custom VM Options... "></p><p>在打开的<code>vmoptions</code>编辑窗口末行添加：<code>-javaagent:你pycharm的安装目录\lib\jetbrains-agent.jar</code></p><p><font size="3" face="arial" color="red">建议直接复制粘贴，格式千万注意！</font></p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/1298173-20200404170707515-288476913.png" alt="编辑展示"></p><p>最后一步也是最重要的事情，重复三遍否则可能会破解失败</p><p><font size="5" face="arial" color="red">修改完配置文件之后重启Pycharm</font></p><p><font size="5" face="arial" color="red">修改完配置文件之后重启Pycharm</font></p><p><font size="5" face="arial" color="red">修改完配置文件之后重启Pycharm</font></p><h2><span id="四-问题解决办法">四 . 问题解决办法</span></h2><p>如果错误则会出现<code>PyCharm</code>打不开的情况，不要着急。</p><p>打开上图的文件（你<code>PyCharm</code>的安装目录\bin），找到pycharm64.exe.vmoptions这个文件.</p><p><font size="5" face="arial" color="red">看看最后一行有没有你刚刚加入的代码！！</font></p><p>再看看你刚才添加的目录是否有问题，建议直接复制粘贴下面的代码：</p><p><strong>-javaagent:你pycharm的安装目录\lib\jetbrains-agent.jar</strong></p><p>一般打不开都是这个原因！</p><p>还有一种方法是，使用了软件一段时候破解然后打不开的：</p><p>这时候可以删除用户配置目录下的<code>PyCharm</code>文件夹<code>(能打开PyCharm就不要删除)</code>：</p><p><code>PyCharm</code>文件夹<strong>，</strong>注意这个文件夹是隐藏目录！</p><blockquote><p><code>windwos：C:\Users\用户名\</code><br><code>macos：~/Library/Preferences/</code><br><code>ubuntu：~/.</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/20191228095203793.png" alt="文件位置"></p><h2><span id="五-输入激活码">五 . 输入激活码</span></h2><p>打开软件上方：Help-&gt;Register页面。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/20191228092948451.png" alt="输入激活码"></p><p>点击OK之后，查看有效期。</p><p>点击上方：Help -&gt; About。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/20191228095545228.png" alt="测试结果"></p><p>如果激活码不行的话，可以试一试服务器激活！</p><p>这里我们选用服务器激活，打开如下页面(Help-&gt;Register)。</p><blockquote><p>点击License server，然后输入<a href="https://fls.jetbrains-agent.com/">https://fls.jetbrains-agent.com</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/1298173-20200331152734685-388035428.png" alt="服务器激活"></p><p>点击Activate，查看有效期。</p><p>点击上方：Help-&gt;About。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/20191228095545228.png" alt="测试结果"></p><h2><span id="六-弹窗问题解决">六 . 弹窗问题解决</span></h2><p>如果每次打开<code>PyCharm</code>都会出现一个弹窗，则是因为<code>import.txt</code>丢失，只需要将<code>import.txt</code>再次放进去即可。</p>]]></content>
      
      
      <categories>
          
          <category> PyCharm永久破解方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyCharm永久破解方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序算法</title>
      <link href="posts/ff8068c0.html"/>
      <url>posts/ff8068c0.html</url>
      
        <content type="html"><![CDATA[<h1><span id="python快速排序算法">Python快速排序算法</span></h1><h2><span id="一-快速排序算法的基本思想">一 . 快速排序算法的基本思想</span></h2><p>快速排序又被称为划分交换排序，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两个数据分别进行快速排序，整个排序的过程可以递归进行，以此达到整个数据变成有序的序列。</p><p>快速排序的分治法的实现类似于<code>Hadoop</code>的<code>Mapreduce</code>的分而治之的思想以及分区操作在<code>Hadoop</code>中也有分区、排序、合并操作。<code>Hadoop</code>大数据技术我会在以后的出一个专题系列。</p><ol><li><p>从数列中挑选出一个元素，我们称之为“基准”。</p></li><li><p>重新排列数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆放在基准值的后边(相同的数值可以放到任意一边)。在这个分区结束之后，该基准就处于数列的中间位置。这个称之为分区操作。</p></li><li><p>递归地把小于基准值的元素子数列和大于基准值元素的子数列排序。</p></li><li><p>递归的最底部情形，是数列的大小是零或者是一，也就是永远都已经被排好序。虽然一直递归下去，但这个算法总归会结束，因为在每次迭代的过程中，他至少会把一个元素摆到它最后的位置去。</p><p>是不是很抽象啊，接下来我们看下这张图片，或许就会有些许理解了。</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg/source/20190331172055940.jpg" alt="快速排序"></p></li></ol><h2><span id="二-快速排序的特点">二 . 快速排序的特点</span></h2><p>​    <code>速度快</code></p><h2><span id="三-算法关键点">三 . 算法关键点</span></h2><ol><li>确定作为基准元素的位置，取一个元素p<code>我们不妨取第一个元素</code>，使得元素p归位<code>序列p前的元素都比p小，p后的都比p大</code>。</li><li>列表被元素p分成两部分，左边的都比p小，右边的都比p大。</li><li>递归完成排序</li></ol><h2><span id="四-实现代码">四 . 实现代码</span></h2><p>快速排序的伪代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># encoding=utf-8</span><span class="token comment"># Time : 2021/2/16 20:11 </span><span class="token comment"># Author : 啵啵</span><span class="token comment"># File : quick_sort.py </span><span class="token comment"># Software: PyCharm</span><span class="token keyword">from</span> cal_time <span class="token keyword">import</span> cal_time<span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>    temp <span class="token operator">=</span> li<span class="token punctuation">[</span>left<span class="token punctuation">]</span>    <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        <span class="token comment"># 从右边找比tmp小的数</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right <span class="token keyword">and</span> li<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> temp<span class="token punctuation">:</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment"># 如果右边的值比基准值小，则把右边的值写到左边的空位置上</span>        li<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>right<span class="token punctuation">]</span>        <span class="token keyword">while</span>  left <span class="token operator">&lt;</span> right <span class="token keyword">and</span> li<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">:</span>            left <span class="token operator">+=</span><span class="token number">1</span>        <span class="token comment"># 如果左边的值比基准值小，则把左边的值写到右边的空位置上</span>        li<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>left<span class="token punctuation">]</span>    <span class="token comment"># temp归位</span>    <span class="token comment"># 当left和right下标相等时，说明此趟排序完成</span>    <span class="token comment"># 这里写left和right都一样，因为他们相遇值一样</span>    li<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> temp    <span class="token keyword">return</span> left<span class="token keyword">def</span> <span class="token function">_quick_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 至少两个元素</span>    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        mid <span class="token operator">=</span> partition<span class="token punctuation">(</span>li<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>        _quick_sort<span class="token punctuation">(</span>li<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        _quick_sort<span class="token punctuation">(</span>li<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token decorator annotation punctuation">@cal_time</span><span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    _quick_sort<span class="token punctuation">(</span>li<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码讲解:</p><p>快速排序算法相对来说比较困难，直接把注释写到代码旁边了。</p><p>大家注意到了没，为什么写了<code>_quick_sort</code>还要再写到quick_sort内执行，因为使用了装饰器，<code>_quick_sort</code>是一个递归函数，则装饰器会在每次函数调用时返回一个结果。我们是想求得整个排序耗费时间而不是每一趟的时间。如果数据量过小，需要提高装饰器的精度才能显示时间，否则只能显示0秒，排序速度太快哈哈哈。</p><h2><span id="五-运行测试">五 . 运行测试</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">li <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"要排序的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span>quick_sort<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序后的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 结果:</span><span class="token comment"># 要排序的列表:[3, 4, 2, 1, 5, 6, 8, 9]</span><span class="token comment"># 排序后的列表:[1, 2, 3, 4, 5, 6, 8, 9]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="六-时间复杂度">六 . 时间复杂度</span></h2><ul><li>最优时间复杂度：<code>O(nlogn)</code></li><li>最坏时间复杂度：O(n<sup>2</sup>)</li><li>稳定性：不稳定</li></ul><p>从一开始快速排序平均需要花费<code>O(nlogn)</code>时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用<code>O(n)</code>的时间。在使用结合（concatenation）的版本中，这项运算也是<code>O(n)</code>。</p><p>在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作<code>logn</code>次嵌套的调用。这个意思就是调用树的深度是<code>O(logn)</code>。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要<code>O(n)</code>的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有<code>O(n)</code>个调用，这些被归纳在O(n)系数中。结果是这个算法仅需使用<code>O(nlogn)</code>时间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python算法 </tag>
            
            <tag> python数据结构 </tag>
            
            <tag> 快速排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序算法</title>
      <link href="posts/96555fb2.html"/>
      <url>posts/96555fb2.html</url>
      
        <content type="html"><![CDATA[<center> 在这里bobo祝大家新年快乐！！</center><h1><span id="python插入排序算法">Python插入排序算法</span></h1><h2><span id="一-插入排序算法的基本思想">一 . 插入排序算法的基本思想</span></h2><p>​    在这里我先举一个小例子，帮助大家理解插入排序算法，就比如现在有一副扑克牌放在桌子上，我们只能看到牌的背面，现在我们一次拿出一张牌，放到手中，依次取若干张，在每取一次牌，我们就插入到手里的牌中，始终保持手中的牌是有序的。</p><ol><li><p>插入排序是指在待排序的元素中，假设前面n-1(其中n&gt;=2)个数已经是排好顺序的。</p></li><li><p>现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。</p></li><li><p>按照此法对所有元素进行插入，直到整个序列排为有序的过程。</p><p>下面我们来看一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/bVbswgT" alt="插入排序"></p></li></ol><hr><h2><span id="二-算法关键点">二 . 算法关键点</span></h2><ol><li>有序区和无序区。</li><li>待插入数值与有序区的比较过程。</li><li>最终确定待插入数值的插入位置。</li></ol><hr><h2><span id="三-实现代码">三 . 实现代码</span></h2><p>​    插入排序的伪代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># encoding=utf-8</span><span class="token comment"># Time : 2021/2/12 20:07 </span><span class="token comment"># Author : 啵啵</span><span class="token comment"># File : insert_sort.py </span><span class="token comment"># Software: PyCharm</span><span class="token comment"># 插入排序算法</span><span class="token keyword">def</span> <span class="token function">insert_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># i表示摸到的牌的下标</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        temp <span class="token operator">=</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment"># j指的是手里的牌的下标</span>        j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token keyword">and</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">:</span>            li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j <span class="token operator">-=</span><span class="token number">1</span>        li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码讲解：</p><ol><li>第一层for循环是决定插入排序算法的趟数，因为有序区只有一个数时，这个数即为最大，不需要进行插入排序，所以下标从1开始算，与有序区的那个数进行比较。</li><li>temp用于临时存储抽取到的数。</li><li>while循环需要确保取到的数与无序的数进行比较并且一旦抽取到的数比有序区的某个数就结束循环。</li><li>li[j+1] = temp这行代码是将抽取到的数插入到正确的位置。</li></ol><p>​    插入排序算法思路相比于冒泡排序算法和选择排序算法有一点难度，重点是要把握好无序区，有序区，位置交换这三点。</p><hr><h2><span id="四-时间复杂度">四 . 时间复杂度</span></h2><p>​    涉及两层循环则时间复杂度为：O(n<sup>2</sup>)</p><hr><h2><span id="五-运行测试">五 . 运行测试</span></h2><p>​    </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">li <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"要排序的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span>insert_sort<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序后的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 结果：</span><span class="token comment"># 要排序的列表:[3, 4, 2, 1, 5, 6, 8, 9]</span><span class="token comment"># 排序后的列表:[1, 2, 3, 4, 5, 6, 8, 9]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python算法 </tag>
            
            <tag> python数据结构 </tag>
            
            <tag> 插入排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序算法</title>
      <link href="posts/43d00a99.html"/>
      <url>posts/43d00a99.html</url>
      
        <content type="html"><![CDATA[<center> 在这里bobo预祝大家新年快乐！！</center><h1><span id="python选择排序算法">Python选择排序算法</span></h1><h2><span id="一-选择排序算法的基本思想">一  . 选择排序算法的基本思想</span></h2><ol><li><p>一趟排序记录最小的数，放到第一个位置。</p></li><li><p>再一趟排序记录列表无序区最小的数，放到第二个位置，直至排序全部依次完成。</p><p>我们来看一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/bVbswmI" alt="选择排序"></p></li></ol><hr><h2><span id="二-算法关键点">二 . 算法关键点</span></h2><ol><li> 有序区和无序区。</li><li> 无序区最小数的位置。</li></ol><hr><h2><span id="三-实现代码">三 . 实现代码</span></h2><p>​    首先看一种比较简单容易理解的选择排序算法思路：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">select_sort_simple</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    li_new <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        min_value <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span>        li_new<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min_value<span class="token punctuation">)</span>        li<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>min_value<span class="token punctuation">)</span>    <span class="token keyword">return</span> li_new<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>性能优化前的实现思路：</p><p>​    通过建立两个列表，使用列表的append方法和remove方法实现数据的排序。</p><p>代码弱点：</p><p>​    <code>但是大家可以仔细想一下，这种算法需要开辟两块内存区域来存放列表，一块保存原数据，另一块保存排序后的数据，假如数据量基数比较大时，这无疑是致命。</code></p><p>​    比较难理解但是效率较高的选择排序算法思路：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">select_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        mic_loc <span class="token operator">=</span> i        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span><span class="token punctuation">:</span>                min_loc <span class="token operator">=</span> j            li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>性能优化后的实现思路：</p><p>​    通过建立单个列表，然后利用列表的下标来替换相对应位置的元素。</p><p>代码讲解：</p><ol><li> 第一层for循环决定选择排序算法的趟数。因为只剩最后一个数时，列表则不需要再次进行排序，所以len(li) - 1。</li><li> min_loc是一个标志位，最小值的下标。默认是无序区的第一个数。</li><li>第二层for循环是无序区相邻两个数进行比较，min_loc标志位保持为较小的数的下标。</li><li>无序区最小值移动到无序区的第一个，此轮循环结束，无序区的个数减一，有序区的个数加一。</li></ol><p>代码优点：</p><p>​    <code>select_sort选择排序算法，只使用了一块内存区域用于存储列表，减小内存的开销。</code></p><p>时间复杂度：</p><p>O(n<sup>2</sup>)</p><h2><span id="四-代码优化">四 . 代码优化</span></h2><p>​    如果无序区的比较一趟之后，第一个数依然是最小的数，则不需要发生位置交换。优化后代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">select_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        min_loc <span class="token operator">=</span> i        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span><span class="token punctuation">:</span>                min_loc <span class="token operator">=</span> j        <span class="token keyword">if</span> min_loc <span class="token operator">!=</span> i<span class="token punctuation">:</span>            li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>min_loc<span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="五-运行测试">五 . 运行测试</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">li <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"要排序的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span>select_sort<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序后的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 结果：</span><span class="token comment"># 要排序的列表:[3, 4, 2, 1, 5, 6, 8, 9]</span><span class="token comment"># 排序后的列表:[1, 2, 3, 4, 5, 6, 8, 9]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选择排序算法 </tag>
            
            <tag> python算法 </tag>
            
            <tag> python数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序算法</title>
      <link href="posts/4d081371.html"/>
      <url>posts/4d081371.html</url>
      
        <content type="html"><![CDATA[<h1><span id="python冒泡排序算法">Python冒泡排序算法</span></h1><h2><span id="一-冒泡排序算法的基本思想">一  . 冒泡排序算法的基本思想</span></h2><ol><li><p>列表每两个相邻的数，如果前面的比后边的数大，则交换这两个数。</p></li><li><p>一趟排序完成之后，则无序区减少一个数，有序区增加一个数。（无序区是为完成排序的数，有序区是已经完成排序的数。）</p><p>下面我们来看一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/shage-sg/cloudimg@master/source/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt="冒泡排序"></p></li></ol><hr><h2><span id="二-代码关键点">二  . 代码关键点</span></h2><ol><li>趟数的概念</li><li>无序区的范围的变化</li></ol><hr><h2><span id="三-实现代码">三  . 实现代码</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                li<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码讲解：</p><ul><li>li是需要排序的列表。</li><li>第一层for循环一共需要遍历多少趟来回，因为最后只剩一个数时，不需要再遍历，则len(li) - 1。</li><li>第二层for循环时一共需要多少趟相邻数据比较，例如：长度为五的列表（下标从零开始）第零趟无序区的数的个数为零，则需要执行四趟，因为第四个数是和第五个数进行比较，比较完成时，最大值已经出现，就不需要再比较。</li><li>列表交换数据。</li></ul><h2><span id="四-时间复杂度">四 . 时间复杂度</span></h2><p>​    因为两层for循环，所以时间复杂度是O(n<sup>2</sup>)</p><h2><span id="五-性能优化">五 . 性能优化</span></h2><p>​    如果冒泡排序中的一趟排序没有发生交换，则说明列表已经有序，则可以直接结束算法。</p><h3><span id="解决思路">解决思路</span></h3><p>​    可以通过使用标志位解决。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 最后一次只剩一个数时不用排序</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 第i趟</span>        exchange <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span> <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> li<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                li<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> li<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>li<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                exchange <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> exchange<span class="token punctuation">:</span>            <span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="六-运行测试">六 . 运行测试</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">li <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"要排序的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span>bubble_sort<span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序后的列表:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 结果：</span><span class="token comment"># 要排序的列表:[3, 4, 2, 1, 5, 6, 8, 9]</span><span class="token comment"># 排序后的列表:[1, 2, 3, 4, 5, 6, 8, 9]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python算法 </tag>
            
            <tag> python数据结构 </tag>
            
            <tag> 冒泡排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存的穿透、击穿、雪崩</title>
      <link href="posts/56739dcf.html"/>
      <url>posts/56739dcf.html</url>
      
        <content type="html"><![CDATA[<h2><span id="一-缓存处理的过程">一 .  缓存处理的过程</span></h2><p>​    <code>前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。</code></p><hr><h2><span id="二-缓存穿透"><strong>二 . 缓存穿透</strong></span></h2><p>​    <strong>描述</strong></p><p>​    <code>指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。因为缓存和数据库中都没有的数据，但是用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</code></p><p>​    <strong>解决方案</strong></p><ol><li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截。</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li></ol><hr><h2><span id="三-缓存击穿">三 . 缓存击穿</span></h2><p>​    <strong>解决方案:</strong></p><ol><li>设置热点数据永远不过期。</li><li>加互斥锁。</li></ol><hr><h2><span id="四-缓存雪崩">四 . 缓存雪崩</span></h2><p>​    <strong>描述</strong></p><p>​    <code>指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机。</code></p><p>​    <strong>与缓存击穿的区别</strong></p><p>​    <code>缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</code></p><p>​    <strong>解决方案</strong></p><ol><li><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</p></li><li><p>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</p></li><li><p>设置热点数据永远不过期。</p><p>​</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 缓存问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存雪崩 </tag>
            
            <tag> 缓存穿透 </tag>
            
            <tag> 缓存击穿 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
